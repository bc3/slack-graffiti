import express from "express";
import figlet from "figlet";
import { json } from "body-parser";
import chalk from "chalk";
import { generateAsciiImage } from "./asciiToImage";
import fs from "fs";

const app = express();
app.use(json());
app.use(express.urlencoded({ extended: true }));

const PORT = process.env.PORT || 3000;

app.post("/slack/graffiti-image", async (req, res) => {
  const { text } = req.body;

  if (!text) {
    return res.send("Please provide a word: `/graffiti hello`");
  }

  // Fetch all available fonts at runtime
  figlet.fonts(async (fontErr, fontList) => {
    if (fontErr || !fontList) {
      console.error(fontErr);
      return res.send("Error loading fonts.");
    }
    const selectedFont = fontList[Math.floor(Math.random() * fontList.length)];

    try {
      const response = {
        response_type: "in_channel",
        blocks: [
          {
            type: "image",
            title: {
              type: "plain_text",
              text: `Graffiti: ${text}`
            },
            image_url: `${req.protocol}://${req.get('host')}/slack/graffiti-image-binary?text=${encodeURIComponent(text)}&font=${encodeURIComponent(selectedFont)}`,
            alt_text: `ASCII art graffiti for ${text}`
          }
        ]
      };
      
      res.json(response);
    } catch (err) {
      console.error(err);
      res.status(500).send("Error generating graffiti image");
    }
  });
});

app.post("/slack/graffiti", async (req, res) => {
    const { text, font, user_name } = req.body;
  
    if (!text) {
      return res.send("Please provide a word: `/graffiti hello`");
    }
  
    // Fetch all available fonts at runtime
    figlet.fonts((fontErr, fontList) => {
      if (fontErr || !fontList) {
        console.error(fontErr);
        return res.send("Error loading fonts.");
      }
      const randomFont = font ?? fontList[Math.floor(Math.random() * fontList.length)] as figlet.Fonts;
  
      figlet.text(text, { font: randomFont }, (err, data) => {
        if (err || !data) {
          console.error(err);
          return res.send("Error generating graffiti.");
        }
  
        // Color each line randomly
        const colors = ["red", "green", "yellow", "blue", "magenta", "cyan", "white"];
        const colored = data
          .split("\n")
          .map(line => (chalk as any)[colors[Math.floor(Math.random() * colors.length)]](line))
          .join("\n");
  
        res.type('text/plain').send(colored);
       
    });
  });
});

//add a route /slack/graffiti-image that return this json
// and image url is the image generated by the /slack/graffiti-image-binary route

app.get("/slack/graffiti-image-binary", async (req, res) => {
  const { text } = req.query;

  if (!text || typeof text !== 'string') {
    return res.status(400).send("Please provide a text parameter");
  }

  // Fetch all available fonts at runtime
  figlet.fonts(async (fontErr, fontList) => {
    if (fontErr || !fontList) {
      console.error(fontErr);
      return res.status(500).send("Error loading fonts.");
    }
    const selectedFont =  fontList[Math.floor(Math.random() * fontList.length)];

    try {
      const imagePath = await generateAsciiImage(text, selectedFont as figlet.Fonts);
      res.sendFile(imagePath, err => {
        // Delete the file after sending
        fs.unlink(imagePath, () => {});
        if (err) {
          console.error(err);
        }
      });
    } catch (err) {
      console.error(err);
      res.status(500).send("Error generating graffiti image");
    }
  });
});

app.listen(PORT, () => {
  console.log(`Slack graffiti app running on port ${PORT}`);
});